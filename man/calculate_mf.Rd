% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_mf.R
\name{calculate_mf}
\alias{calculate_mf}
\title{Calculate mutation frequency}
\usage{
calculate_mf(
  mutation_data,
  cols_to_group = "sample",
  subtype_resolution = "none",
  variant_types = c("snv", "deletion", "insertion", "complex", "mnv", "sv", "ambiguous",
    "uncategorized"),
  calculate_depth = TRUE,
  correct_depth = TRUE,
  correct_depth_by_indel_priority = FALSE,
  precalc_depth_data = NULL,
  d_sep = "\\t",
  summary = TRUE,
  retain_metadata_cols = NULL
)
}
\arguments{
\item{mutation_data}{The data frame to be processed containing mutation data.
Required columns are listed below.
Synonymous names for these columns are accepted.
\itemize{
\item \code{contig}: The reference sequence name.
\item \code{start}: 1-based start position of the feature.
\item \code{alt_depth}: The read depth supporting the alternate allele.
\item \code{variation_type}: The category to which this variant is assigned.
\item subtype_col: The column containing the mutation subtype. This
column depends on the \code{subtype_resolution} parameter.
\item reference context: The column containing the referene base(s) for the
mutation. This column depends on the \code{subtype_resolution} parameter.
\item cols to group: all columns across which you want to calculate
the mutation frequency. Ex. \code{c("tissue", "dose")}. These columns should be listed
in cols_to_group.
}
It is also required to include the total_depth column if you are calculating
depth from the mutation data. If you are using precalculated depth data, the
total_depth column is not required.}

\item{cols_to_group}{A vector of grouping variables: this should be the
groups of interest that you want to calculate a frequency for.
For instance, getting the frequency by \code{sample}. Other options might
include \code{dose}, \code{locus}, or, \code{c("sample","locus")}. All listed variables
must be a column in the mutation_data.}

\item{subtype_resolution}{The resolution of the mutation subtypes. Options are
\itemize{
\item "none" calculates mutation frequencies across all selected
grouping columns.
\item "type" calculates mutation frequencies across all selected
grouping columns for each \code{variation_type} seperately; snv, mnv, deletion,
insertion, complex, sv, ambiguous, uncategorized.
\item "base_6" calculates mutation frequencies across all selected
grouping columns for each variation_type with snv mutations separated by
\code{normalized_subtype}; C>A, C>G, C>T, T>A, T>C, T>G. The reference context is
\code{normalized_ref}.
\item "base_12" calculates mutation frequencies across all
selected grouping columns for each variation_type with snv mutations
separated by \code{subtype}; A>C, A>G, A>T, C>A, C>G, C>T, G>A, G>C, G>T,
T>A, T>C, T>G. The reference context is \code{short_ref}.
\item "base_96" calculates mutation frequencies across all
selected grouping columns for each variation_type with snv mutations
separated by \code{normalized_context_with_mutation}, i.e. the 96-base
trinucleotide context. Ex. A\[C>T\]A. The reference context is
\code{normalized_context}.
\item "base_192" calculates mutation frequencies across all
selected grouping columns for each variation_type with snv mutations
separated by \code{context_with_mutation}, i.e. the 192-base trinucleotide
context. Ex A\[G>A\]A. The reference context is \code{context}.
}}

\item{variant_types}{Use this parameter to choose which variation types
to include in the mutation counts. Provide a character vector of the
variation types that you want to include. Alternatively, provide a
character vector of the variation types that you want to exclude preceded
by "-". Options are: "snv", "complex", "deletion", "insertion", "mnv", "sv",
"ambiguous", "uncategorized". Ex. inclusion: "snv", exclusion: "-snv".
Default includes all variants. For \code{calculate_depth = TRUE}: Regardless of
whether or not a variant is included in the mutation counts, the total_depth
for that position will be counted.}

\item{calculate_depth}{A logical variable, whether to calculate the
per-group total_depth from the mutation data. If set to TRUE, the mutation
data must contain a total_depth value for every sequenced base (including
variants AND no-variant calls). If set to FALSE, pre-calculated per-group
total_depth values may be supplied at the desired subtype_resolution
using the precalc_depth_data parameter. Alternatively, if no per-group
total_depth is available, per-group mutation counts will be calculated,
but mutation frequency will not. In such cases, mutation subtype proportions
will not be normalized to the total_depth.}

\item{correct_depth}{A logical value. If TRUE, the function will correct the
\code{total_depth} column in \code{mutation_data} in order to prevent
double-counting the \code{total_depth} values for the same genomic position.
For rows with the same sample contig, and start values, the \code{total_depth}
will be retained for only one row. All other rows in the group will have their
\code{total_depth} set to 0. The default is FALSE}

\item{correct_depth_by_indel_priority}{A logical value. If TRUE, during depth
correction, should there be different \code{total_depth} values within a
group of rows with the same sample, contig, and start values, the
\code{total_depth} value for the row with the highest priority
\code{variation_type} will be retained, while the other rows will have their
\code{total_depth} set to 0. \code{variation_type} priority order is:
deletion, complex, insertion, snv, mnv, sv, uncategorised, ambiguous, no_variant.
If FALSE, the \code{total_depth} value for the first row in the group will
be retained, while the other rows will have their \code{total_depth} set to
0. The default is TRUE.}

\item{precalc_depth_data}{A data frame or a file path to a text file
containing pre-calculated per-group total_depth values. This data frame
should contain the columns for the desired grouping variable(s)
and the reference context at the desired subtype resolution (if applicable).
The precalculated total_depth column(s) should be called one of
\code{group_depth} and \code{subtype_depth}. \code{group_depth} is used for subtype
resolutions of "none", "type", and all non-snv mutations in "base_6",
"base_12", "base_96", and "base_192". \code{subtype_depth} is used for snv
mutations in "base_6", "base_12", "base_96", and "base_192". You can
access a list of context values for each subtype resolution using
\code{MutSeqR::context_list$your_subtype_resolution}.}

\item{d_sep}{The delimiter used in the precalc_depth_data, if applicable.
Default is tab-delimited.}

\item{summary}{A logical variable, whether to return a summary table
(i.e., where only relevant columns for frequencies and groupings are
returned). Setting this to false returns all columns in the original
mutation_data, which might make plotting more difficult, but may provide
additional flexibility to power users.}

\item{retain_metadata_cols}{a character vector that contains the names of the
metadata columns that you would like to retain in the summary table.
This may be useful for plotting your summary data. Ex. retain the "dose"
column when summarising by "sample".}
}
\value{
A data frame with the mutation frequency calculated. If summary
is set to TRUE, the data frame will be a summary table with the mutation
frequency calculated for each group. If summary is set to FALSE, the
mutation frequency will be appended to each row of the original
mutation_data.
\itemize{
\item \code{sum_min}: The sum of all mutations within the group, calculated
using the "min" method for mutation counting. All identical mutations
within a samples are assumed to be the result of clonal expansion and are
thus only counted once.
\item \code{sum_max}: The sum of all mutations within the group, calculated
using the "max" method for mutaiton counting. All identical mutations
within a sample are assumed to be idenpendant mutational evens and are
included in the mutation frequency calculation.
\item \code{mf_min}: The mutation frequency calculated using the "min"
method for mutation counting. mf_min = sum_min / depth.
\item \code{mf_max}: The mutation frequency calculated using the "max"
method for mutation counting. mf_max = sum_max / depth.
\item \code{proportion_min}: The proportion of each mutation
subtype within the group, normalized to the depth. Calculated
using the "min" method. This is only calculated if \code{subtype_resolution}
is not "none". If no depth is calculated or provided, proportion is
calculated without normalization to the depth.
\item \code{proportion_max}: The proportion of each mutation
subtype within the group, normalized to its read depth. Calculated
using the "max" method. This is only calculated if \code{subtype_resolution}
is not "none". If no depth is calculated or provided, proportion is
calculated without normalization to the depth.
}
}
\description{
Calculates the mutation frequency for arbitrary groupings and creates a new
dataframe with the results. Mutation frequency is # mutations / total bases,
but this can be subset in different ways: e.g., by mutation context. In this
case, it is necessary to change the denominator of total bases to reflect
the sequencing depth at the proper reference bases under consideration.
Additionally, by default, the operation is run by default using both the minimum
and maximum independent methods for counting mutations.
}
\details{
Depth correction is important for preventing double-counting of reads in
mutation data when summing the total_depth across samples or other groups.
Generally, when several mutations have been detected at the same genomic
position, within a sample, the total_depth value will be the same for all of
them. However, in some datasets, whenever a deletion is detected, the data
may contain an additional row with the same genomic position calling a
"no_variant". The total_depth will differ between the deletion and the
no_variant. In these cases, correct_depth_by_indel_priority == TRUE will ensure that
the total_depth value for the deletion is retained, while the total_depth
value for the no_variant is removed.
}
\examples{
# Load example data
example_file <- system.file("extdata", "Example_files",
                            "example_mutation_data_filtered.rds",
                            package = "MutSeqR")
example_data <- readRDS(example_file)

# Example 1 Calculate mutation frequency by sample.
# Calculate depth from the mutation data
mf_example <- calculate_mf(mutation_data = example_data,
                           cols_to_group = "sample")
# Example 2: Calculate the trinucleotide mutation proportions for each dose 
# TODO - Add correct_depth parameter to examples!
mf_96_example <- calculate_mf(mutation_data = example_data,
                              cols_to_group = "dose",
                              subtype_resolution = "base_96",
                              variant_types  = "snv")
# Example 3: Calculate the mean mutation frequency for each 6 base subtype
# per dose
# calculate_mf does not calculate mean mutation frequency for
# groups; this function only sums mutations across groups. Thus, if you are
# interested in calculating the mean of a group, this must be done
# separately.
# First, calculate 6 base MF per sample. Retain the dose column.
mf_6_example <- calculate_mf(mutation_data = example_data,
                             cols_to_group = "sample",
                             subtype_resolution = "base_6",
                             retain_metadata_cols = "dose")
# Note: NA values in retain_metadata_cols. When we create a summary table
# that includes mutation subtypes, there may occasionally be NA values in
# the metadata columns. This is because the mutation data does not contain
# any mutations (filtered or not) for that particular subtype within the
# given group. For example, our example_data does not contain any ambiguous
# or uncategorized mutations, so the dose column is NA for all those
# mutations in the summary table. This will not affect downstream analyses.

# Calculate the mean MF for each 6 base subtype per dose
mf_6_mean_example <- mf_6_example \%>\%
 dplyr::group_by(dose, normalized_subtype) \%>\%
 dplyr::summarise(mean_mf_min = mean(mf_min),
                  se_mf_min = sd(mf_min) / sqrt(dplyr::n()),
                  mean_mf_max = mean(mf_max),
                  se_mf_max = sd(mf_max) / sqrt(dplyr::n()))

# Example 4: Calculate MF using precalculated depth data
sample_depth_example <- data.frame(sample = c("dna00973.1", "dna00974.1",
                                              "dna00975.1", "dna00976.1",
                                              "dna00977.1", "dna00978.1",
                                              "dna00979.1", "dna00980.1",
                                              "dna00981.1", "dna00982.1",
                                              "dna00983.1", "dna00984.1",
                                              "dna00985.1", "dna00986.1",
                                              "dna00987.1", "dna00988.1",
                                              "dna00989.1", "dna00990.1",
                                              "dna00991.1", "dna00992.1",
                                              "dna00993.1", "dna00994.1",
                                              "dna00995.1", "dna00996.1"),
                                   group_depth = c(565395266, 755574283,
                                                   639909215, 675090988,
                                                   598104021, 611295330,
                                                   648531765, 713240735,
                                                   669734626, 684951248,
                                                   716913381, 692323218,
                                                   297661400, 172863681,
                                                   672259724, 740901132,
                                                   558051386, 733727643,
                                                   703349287, 884821671,
                                                   743311822, 799605045,
                                                   677693752, 701163532))
mf_example_precalc <- calculate_mf(mutation_data = example_data,
                                   cols_to_group = "sample",
                                   calculate_depth = FALSE,
                                   precalc_depth_data = sample_depth_example)

# Example 5: Calculate MF using precalculated depth data for 6 base
# mutation subtypes per sample.
# The base_6 resolution uses reference context 'normalized_ref'; C or T.
# Our precalc_depth_data needs group_depth (depth per sample) and the
# subtype_depth (depth per sample AND per normalized_ref)
# We will create the example precalc_depth data for the base_6 resolution
# from Example 3 results for simplicity.
sample_subtype_depth_example <- mf_6_example \%>\%
 dplyr::select(sample, normalized_ref, group_depth, subtype_depth) \%>\%
 unique() \%>\%
dplyr::filter(normalized_ref != "N")
mf_6_example_precalc <- calculate_mf(mutation_data = example_data,
                                     cols_to_group = "sample",
                                     subtype_resolution = "base_6",
                                     calculate_depth = FALSE,
                                     precalc_depth_data = sample_subtype_depth_example)
}
