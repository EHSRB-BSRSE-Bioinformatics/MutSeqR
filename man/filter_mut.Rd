% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_mut.r
\name{filter_mut}
\alias{filter_mut}
\title{Filter your mutation data}
\usage{
filter_mut(
  mutation_data,
  correct_depth = FALSE,
  correct_depth_to_indel = TRUE,
  vaf_cutoff = 1,
  snv_in_germ_mnv = FALSE,
  rm_abnormal_vaf = FALSE,
  custom_filter_col = NULL,
  custom_filter_val = NULL,
  custom_filter_rm = FALSE,
  regions = NULL,
  regions_filter,
  allow_half_overlap = FALSE,
  rg_sep = "\\t",
  is_0_based_rg = TRUE,
  rm_filtered_mut_from_depth = FALSE,
  return_filtered_rows = FALSE
)
}
\arguments{
\item{mutation_data}{Your mutation data.}

\item{correct_depth}{A logical value. If TRUE, the function will correct the
\code{total_depth} column in \code{mutation_data} in order to prevent
double-counting the \code{total_depth} values for the same genomic position.
For rows with the same sample contig, and start values, the \code{total_depth}
will be retained for only one row. All other rows in the group will have their
\code{total_depth} set to 0. The default is FALSE}

\item{correct_depth_to_indel}{A logical value. If TRUE, during depth
correction, should there be different \code{total_depth} values within a
group of rows with the same sample, contig, and start values, the
\code{total_depth} value for the row with the highest priority
\code{variation_type} will be retained, while the other rows will have their
\code{total_depth} set to 0. \code{variation_type} priority order is:
deletion, complex, insertion, snv, mnv, sv, uncategorised, no_variant.
If FALSE, the \code{total_depth} value for the first row in the group will
be retained, while the other rows will have their \code{total_depth} set to
0. The default is TRUE.}

\item{vaf_cutoff}{Filter out ostensibly germline variants using a cutoff for
variant allele fraction (VAF). Any variant with a \code{vaf} larger than
the cutoff will be filtered. The default is 1 (no filtering). It is
recommended to use a value of 0.01 (i.e. 1\%) to retain only somatic
variants.}

\item{snv_in_germ_mnv}{Filter out snv variants that overlap with
germline mnv variants within the same samples. mnv variants will be
considered germline if their vaf > vaf_cutoff. Default is FALSE.}

\item{rm_abnormal_vaf}{A logical value. If TRUE, rows in
\code{mutation_data} with a variant allele fraction (VAF) between 0.05 and
0.45 or between 0.55 and 0.95 will be removed. We expect variants to have a
VAF ~0. 0.5, or 1, reflecting rare somatic mutations, heterozygous germline
mutations, and homozygous germline mutations, respectively. Default is
FALSE.}

\item{custom_filter_col}{The name of the column in mutation_data to apply a
custom filter to. This column will be checked for specific values, as defined
by \code{custom_filter_val}. If any row in this column contains one of the
specified values, that row will either be flagged in the
\code{filter_mut column} or, if specified by \code{custom_filter_rm},
removed from mutation_data.}

\item{custom_filter_val}{A set of values used to filter rows in
\code{mutation_data} based on \code{custom_filter_col}. If a row in
\code{custom_filter_col} matches any value in \code{custom_filter_val},
it will either be set to TRUE in the \code{filter_mut} column or removed,
depending on \code{custom_filter_rm}.}

\item{custom_filter_rm}{A logical value. If TRUE, rows in custom_filter_col
that match any value in custom_filter_val will be removed from the
mutation_data. If FALSE, filter_mut will be set to TRUE for those rows.}

\item{regions}{Remove rows that are within or outside of specified regions.
Provide either a data frame or a file path of the specified intervals. Your
regions must contain "contig", "start", and "end".  Use the
\code{regions_filter} parameter to specify whether rows within the regions
should be kept versus removed. To use one of the TSpanels, set the regions
parameter as follows: \code{regions = load_regions_file("TSpanel_mouse")}.
Change the species as needed for human/rat.}

\item{regions_filter}{Specifies how the provided \code{regions} should be
applied to \code{mutation_data}. Acceptable values are "remove_within" or
"keep_within". If set to "remove_within", any rows that fall within the
specified regions wil be removed from mutation_data. If set to
"keep_within", only the rows within the specified regions will be kept in
mutation_data, and all other rows will be removed.}

\item{allow_half_overlap}{A logical value. If TRUE, rows that start or end
in your \code{regions}, but extend outside of them in either direction will
be included in the filter. If FALSE, only rows that start and end within the
\code{regions} will be included in the filter. Default is FALSE.}

\item{rg_sep}{The delimiter for importing the \code{regions} file, if
applicable. Default is tab-delimited.}

\item{is_0_based_rg}{A logical value indicating whether the genomic intervals
you provided in \code{regions} are 0_based. Set this to TRUE if you are
using one of the TSpanels.}

\item{rm_filtered_mut_from_depth}{A logical value. If TRUE, the function will
subtract the \code{alt_depth} of rows that were flagged by the
\code{filter_mut} column from their \code{total_depth}. This will treat
flagged variants as N-calls. This will not apply to variants flagged as
germline by the \code{vaf_cutoff}. However, if the germline variant
has additional filters applied, then the subtraction will still occur.
If FALSE, the \code{alt_depth} will be retained in the
\code{total_depth} for all variants.  Default is FALSE.}

\item{return_filtered_rows}{A logical value. If TRUE, the function will
return both the filtered mutation data and the rows that were
removed/flagged in a seperate data frame. The two dataframes will be
returned inside a list, with names \code{mutation_data} and
\code{filtered_rows}. Default is FALSE.}
}
\description{
This function creates a filter_mut column that will be read by
the \code{calculate_mut_freq} function. Variants with filter == TRUE will
not be included in final mutation counts. This function may also remove
records of given loci from the mutation data based on user specification.
Running this function again on the same data will not overide the previous
filters. To reset previous filters, set the filter_mut column values to
FALSE.
}
\details{
Depth correction is important for preventing double-counting of reads in
mutation data when summing the total_depth across samples or other groups.
Generally, when several mutations have been detected at the same genomic
position, within a sample, the total_depth value will be the same for all of
them. However, in some datasets, whenever a deletion is detected, the data
may contain an additional row with the same genomic position calling a
"no_variant". The total_depth will differ between the deletion and the
no_variant. In these cases, correct_depth_to_indel == TRUE will ensure that
the total_depth value for the deletion is retained, while the total_depth
value for the no_variant is removed.
}
